name: CI
on:
  push:
    branches:
      - main
    tags: ['*']
  pull_request:
  workflow_dispatch:
concurrency:
  # Skip intermediate builds: always.
  # Cancel intermediate builds: only if it is a pull request build.
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ startsWith(github.ref, 'refs/pull/') }}
jobs:
  test:
    name: Julia ${{ matrix.version }} - ${{ matrix.os }} - ${{ matrix.arch }}
    runs-on: ${{ matrix.os }}
    timeout-minutes: 60
    permissions:
      actions: write
      contents: read
    strategy:
      fail-fast: false
      matrix:
        version:
          - 'lts'
          - '1'
        os:
          - ubuntu-latest
        arch:
          - x64
    steps:
      - uses: actions/checkout@v4
      - uses: julia-actions/setup-julia@v2
        with:
          version: ${{ matrix.version }}
          arch: ${{ matrix.arch }}
      - uses: julia-actions/cache@v2
      - uses: julia-actions/julia-buildpkg@v1
      - uses: julia-actions/julia-runtest@v1

      # New step to generate the CSV
      - name: Generate coverage summary for this PR
        if: matrix.version == '1' && matrix.os == 'ubuntu-latest' && matrix.arch == 'x64'
        shell: julia --project --color=yes {0}
        run: |
          using Pkg
          Pkg.add(["Coverage","CSV"])
          using Coverage

          # Collect coverage from .cov files
          coverage = process_folder("src")

          # Open a file to write the summary
          open("coverage_summary_pr.csv", "w") do io
              # Write the CSV header
              println(io, "file,covered_lines,total_lines,coverage_percentage")

              # Write data for each file
              for file in coverage
                  # get_summary returns a tuple: (covered_lines, total_lines)
                  covered_lines, total_lines = get_summary(file)
                  
                  if total_lines > 0
                      filename = file.filename
                      percentage = round(100 * covered_lines / total_lines, digits=2)
                      println(io, "$filename,$covered_lines,$total_lines,$percentage")
                  end
              end
          end


          println("Coverage summary saved to coverage_summary_pr.csv")
          run(`cat coverage_summary_pr.csv`)

      # New step to upload the CSV as an artifact
      - uses: actions/upload-artifact@v4
        with:
          name: coverage-summary-pr
          path: coverage_summary_pr.csv

  test-base-branch:
    name: Coverage vs Target Branch
    needs: test
    runs-on: ubuntu-latest
    # This 'if' condition ensures the job only runs on pull request events
    if: github.event_name == 'pull_request'
    permissions:
      actions: write
      contents: read
      pull-requests: write
    steps:
      - name: Checkout base branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}

      - name: Setup Julia
        uses: julia-actions/setup-julia@v2
        with:
          version: '1'

      - name: Download PR Coverage Artifact
        uses: actions/download-artifact@v4
        with:
          name: coverage-summary-pr
          path: . # Download to current directory

      - name: Generate Coverage Comparison Table
        id: generate-table
        continue-on-error: true # Allow this step to fail without stopping the workflow
        shell: julia --project --color=yes {0}
        run: |
          using Pkg
          Pkg.add(["Coverage", "CSV", "DataFrames", "PrettyTables"])
          using Coverage, CSV, DataFrames, PrettyTables, Printf

          # --- Generate Base Coverage (as before) ---
          coverage = process_folder("src")
          open("coverage_summary_base.csv", "w") do io
              println(io, "file,covered_lines,total_lines,coverage_percentage")
              for file in coverage
                  covered_lines, total_lines = get_summary(file)
                  if total_lines > 0
                      filename = file.filename
                      percentage = round(100 * covered_lines / total_lines, digits = 2)
                      println(io, "$filename,$covered_lines,$total_lines,$percentage")
                  end
              end
          end
          println("Base coverage summary saved to coverage_summary_base.csv")

          # --- 1. Load Data ---
          base_df = CSV.read("coverage_summary_base.csv", DataFrame)
          pr_df = CSV.read("coverage_summary_pr.csv", DataFrame)

          # --- 2. Join and Calculate Deltas ---
          rename!(base_df, :coverage_percentage => :base_coverage)
          rename!(pr_df, :coverage_percentage => :pr_coverage)
          comparison_df = outerjoin(base_df[!, [:file, :base_coverage]], pr_df[!, [:file, :pr_coverage]], on = :file)
          comparison_df.base_coverage = coalesce.(comparison_df.base_coverage, 0.0)
          comparison_df.pr_coverage = coalesce.(comparison_df.pr_coverage, 0.0)
          comparison_df.change = comparison_df.pr_coverage .- comparison_df.base_coverage

          # Format change to be a signed string
          comparison_df.change_str = [chg == 0.0 ? "±0.0" : @sprintf("%+.2f", chg) for chg in comparison_df.change]

          # --- 3. Create Markdown Table ---
          # Define Highlighters for the table
          mh_1 = MarkdownHighlighter(
            (data, i, j) -> (j == 4) && data[i, 4] > <0,
            MarkdownDecoration(bold = true)
           )

          # Select and rename columns for the final table
          final_table_df = select(comparison_df, :file, :base_coverage, :pr_coverage, :change, :change_str)
          rename!(final_table_df, :file => "File", :base_coverage => "Base (%)", :pr_coverage => "PR (%)", :change_str => "Change (%)")

          # Write the markdown table to a file
          open("cov_table.md", "w") do io
              pretty_table(io,
                  final_table_df[!, ["File", "Base (%)", "PR (%)", "Change (%)"]]; # Use the string version of change
                  backend = Val(:markdown),
                  highlighters = (mh_1, mh_1)
              )
          end
          println("Coverage comparison table saved to cov_table.md")

          base_coverage = sum(base_df.covered_lines) / sum(base_df.total_lines)
          pr_coverage = sum(pr_df.covered_lines) / sum(pr_df.total_lines)

          println("Base Coverage: $(base_coverage * 100)%")
          println("PR Coverage:   $(pr_coverage * 100)%")

          # The critical check
          if pr_coverage < base_coverage
            # 1. Print a clear error message for the logs
            println("❌ ERROR: Coverage decreased! Failing the build.")
            
            # 2. Tell the Julia process to exit with a failure code
            exit(1)
          end

          println("✅ Coverage check passed!")

      - name: Read coverage table from file
        id: file-reader
        if: steps.generate-table.outcome == 'success' || steps.generate-table.outcome == 'failure'
        uses: jsdaniell/create-json@v1.2.2
        with:
          name: 'cov_table'
          json: ${{ toJSON(fromJSON('{}')) }} # Workaround for single-file reading
          # This action reads the file content into steps.file-reader.outputs.cov_table
          text: $(cat cov_table.md)

      - name: Create or Update PR Comment
        # This step runs even if the generation step failed, to report the status
        if: success() || failure()
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          # The hidden HTML comment that acts as a persistent ID
          comment-id: '<!-- GITHUB_ACTIONS_COVERAGE_COMMENT -->'
          # The body of the comment. We build it here.
          body: |
            ## 📊 Code Coverage Report

            ${{ steps.file-reader.outputs.cov_table }}

            ---
            *Report generated by GitHub Actions. This comment will be updated on new commits.*
            <!-- GITHUB_ACTIONS_COVERAGE_COMMENT -->
          # 'replace' ensures the entire old comment is wiped and replaced with the new one
          edit-mode: replace

      - name: Check critical step status
        if: steps.generate-table.outcome == 'failure'
        run: |
          echo "The coverage of the PR is not >= the target branch OR the workflow errored."
          exit 1


  docs:
    name: Documentation
    runs-on: ubuntu-latest
    permissions:
      actions: write # needed to allow julia-actions/cache to proactively delete old caches that it has created
      contents: write
      statuses: write
    steps:
      - uses: actions/checkout@v4
      - uses: julia-actions/setup-julia@v2
        with:
          version: '1'
      - uses: julia-actions/cache@v2
      - name: Configure doc environment
        shell: julia --project=docs --color=yes {0}
        run: |
          using Pkg
          Pkg.develop(PackageSpec(path=pwd()))
          Pkg.instantiate()
      - uses: julia-actions/julia-buildpkg@v1
      - uses: julia-actions/julia-docdeploy@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DOCUMENTER_KEY: ${{ secrets.DOCUMENTER_KEY }}
      - name: Run doctests
        shell: julia --project=docs --color=yes {0}
        run: |
          using Documenter: DocMeta, doctest
          using MapUnroll
          DocMeta.setdocmeta!(MapUnroll, :DocTestSetup, :(using MapUnroll); recursive=true)
          doctest(MapUnroll)
  runic:
    name: Runic formatting
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: fredrikekre/runic-action@v1
        with:
          version: '1'
