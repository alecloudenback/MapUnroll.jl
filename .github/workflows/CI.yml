name: CI
on:
  push:
    branches:
      - main
    tags: ['*']
  pull_request:
  workflow_dispatch:
concurrency:
  # Skip intermediate builds: always.
  # Cancel intermediate builds: only if it is a pull request build.
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ startsWith(github.ref, 'refs/pull/') }}
jobs:
  test:
    name: Julia ${{ matrix.version }} - ${{ matrix.os }} - ${{ matrix.arch }}
    runs-on: ${{ matrix.os }}
    timeout-minutes: 60
    permissions:
      actions: write
      contents: read
    strategy:
      fail-fast: false
      matrix:
        version:
          - 'lts'
          - '1'
        os:
          - ubuntu-latest
        arch:
          - x64
    steps:
      - uses: actions/checkout@v4
      - uses: julia-actions/setup-julia@v2
        with:
          version: ${{ matrix.version }}
          arch: ${{ matrix.arch }}
      - uses: julia-actions/cache@v2
      - uses: julia-actions/julia-buildpkg@v1
      - uses: julia-actions/julia-runtest@v1

      # New step to generate the CSV
      - name: Generate coverage summary for this PR
        if: matrix.version == '1' && matrix.os == 'ubuntu-latest' && matrix.arch == 'x64'
        shell: julia --project --color=yes {0}
        run: |
          using Pkg
          Pkg.add(["Coverage","CSV"])
          using Coverage

          # Collect coverage from .cov files
          coverage = process_folder("src")

          # Open a file to write the summary
          open("coverage_summary_pr.csv", "w") do io
              # Write the CSV header
              println(io, "file,covered_lines,total_lines,coverage_percentage")

              # Write data for each file
              for file in coverage
                  # get_summary returns a tuple: (covered_lines, total_lines)
                  covered_lines, total_lines = get_summary(file)
                  
                  if total_lines > 0
                      filename = file.filename
                      percentage = round(100 * covered_lines / total_lines, digits=2)
                      println(io, "$filename,$covered_lines,$total_lines,$percentage")
                  end
              end
          end


          println("Coverage summary saved to coverage_summary_pr.csv")
          run(`cat coverage_summary_pr.csv`)

      # New step to upload the CSV as an artifact
      - uses: actions/upload-artifact@v4
        with:
          name: coverage-summary-pr
          path: coverage_summary_pr.csv

  test-base-branch:
    name: Coverage vs Target Branch
    needs: test
    runs-on: ubuntu-latest
    # This 'if' condition ensures the job only runs on pull request events
    if: github.event_name == 'pull_request'
    permissions:
      actions: write
      contents: read
    steps:
      - name: Checkout base branch
        uses: actions/checkout@v4
        with:
          # This is the key: it checks out the target branch of the PR (e.g., 'main')
          ref: ${{ github.event.pull_request.base.ref }}

      - name: Setup Julia
        uses: julia-actions/setup-julia@v2
        with:
          version: '1' # A single stable version is sufficient for the base check

      - name: Download PR Branch Coverage Artifacts
        uses: actions/download-artifact@v4
        with:
          # Use a pattern to grab the PR artifact, regardless of the matrix build
          name: coverage-summary-pr
          path: . # <-- Downloads file(s) into the current directory

      - uses: julia-actions/cache@v2
      - uses: julia-actions/julia-buildpkg@v1
      - uses: julia-actions/julia-runtest@v1

      - name: Generate base coverage summary
        continue-on-error: true 
        shell: julia --project --color=yes {0}
        run: |
          using Pkg
          Pkg.add(["Coverage","CSV", "DataFrames","PrettyTables"])
          using Coverage

          coverage = process_folder("src")
          
          open("coverage_summary_base.csv", "w") do io
              println(io, "file,covered_lines,total_lines,coverage_percentage")
              for file in coverage
                  covered_lines, total_lines = get_summary(file)
                  if total_lines > 0
                      filename = file.filename
                      percentage = round(100 * covered_lines / total_lines, digits=2)
                      println(io, "$filename,$covered_lines,$total_lines,$percentage")
                  end
              end
          end

          println("Base coverage summary saved to coverage_summary_base.csv")

          using CSV, DataFrames

          # --- 1. Load Data ---
          # The artifact is downloaded into a directory with the same name
          base_file = "coverage_summary_base.csv"
          
          # Find the first CSV file in the downloaded PR artifacts directory
          pr_file = "coverage_summary_pr.csv"

          println("Comparing base file: $(base_file)")
          println("Comparing PR file: $(pr_file)")

          base_df = CSV.read(base_file, DataFrame)
          pr_df = CSV.read(pr_file, DataFrame)

          # --- 2. Join DataFrames ---
          # Rename columns to avoid clashes after joining
          rename!(base_df, :coverage_percentage => :base_coverage)
          rename!(pr_df, :coverage_percentage => :pr_coverage)
          
          # An outer join correctly handles new files (missing in base) and deleted files (missing in pr)
          comparison_df = outerjoin(base_df[!, [:file, :base_coverage]], pr_df[!, [:file, :pr_coverage]], on = :file)

          # --- 3. Calculate Deltas ---
          # Replace missing values with 0. A new file has 0 base coverage; a deleted file has 0 pr coverage.
          comparison_df.base_coverage = coalesce.(comparison_df.base_coverage, 0.0)
          comparison_df.pr_coverage = coalesce.(comparison_df.pr_coverage, 0.0)
          
          # Calculate the change
          comparison_df.change = comparison_df.pr_coverage - comparison_df.base_coverage

          @show comparison_df

          using PrettyTables
          mh_1 = MarkdownHighlighter(
           (data, i, j) -> (j == 4) && data[i, 4] > <0,
           MarkdownDecoration(bold = true)
          )

          open("cov_table.md", "w") do io
            pretty_table(
            data;
            alignment = [:l, :r, :r, :r],
            backend = Val(:markdown),
            header = header,
            highlighters = (mh_1, mh_1)
            )
          end

          base_coverage = sum(base_df.covered_lines) / sum(base_df.total_lines)
          pr_coverage = sum(pr_df.covered_lines) / sum(pr_df.total_lines)

          println("Base Coverage: $(base_coverage * 100)%")
          println("PR Coverage:   $(pr_coverage * 100)%")

          # The critical check
          if pr_coverage < base_coverage
            # 1. Print a clear error message for the logs
            println("❌ ERROR: Coverage decreased! Failing the build.")
            
            # 2. Tell the Julia process to exit with a failure code
            exit(1)
          end

          println("✅ Coverage check passed!")

      - name: Upload comparison table
        uses: actions/upload-artifact@v4
        with:
          name: cov-comparison
          path: cov_table.md


  docs:
    name: Documentation
    runs-on: ubuntu-latest
    permissions:
      actions: write # needed to allow julia-actions/cache to proactively delete old caches that it has created
      contents: write
      statuses: write
    steps:
      - uses: actions/checkout@v4
      - uses: julia-actions/setup-julia@v2
        with:
          version: '1'
      - uses: julia-actions/cache@v2
      - name: Configure doc environment
        shell: julia --project=docs --color=yes {0}
        run: |
          using Pkg
          Pkg.develop(PackageSpec(path=pwd()))
          Pkg.instantiate()
      - uses: julia-actions/julia-buildpkg@v1
      - uses: julia-actions/julia-docdeploy@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DOCUMENTER_KEY: ${{ secrets.DOCUMENTER_KEY }}
      - name: Run doctests
        shell: julia --project=docs --color=yes {0}
        run: |
          using Documenter: DocMeta, doctest
          using MapUnroll
          DocMeta.setdocmeta!(MapUnroll, :DocTestSetup, :(using MapUnroll); recursive=true)
          doctest(MapUnroll)
  runic:
    name: Runic formatting
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: fredrikekre/runic-action@v1
        with:
          version: '1'
